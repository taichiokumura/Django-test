<!DOCTYPE html>
{% load static %}
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Touch Image Viewer</title>
    <link rel="stylesheet" href="{% static 'css/reset.css' %}">
    <link rel="stylesheet" href="{% static 'css/map.css' %}">
</head>
<body>
    <h1>{{ title }}</h1>
    <div id="container">
        <img id="baseImage" class="image" src="{% static 'media/river_sample.jpg' %}" alt="Base Image">
        <img id="overlayImage" class="image" src="{{ image_url }}" alt="Overlay Image">
    </div>

    <button id="saveButton">この位置に決める</button>

    <script>
        const baseImage = document.getElementById('baseImage');
        const overlayImage = document.getElementById('overlayImage');
        const saveButton = document.getElementById('saveButton');
        let initialDistance = null;
        let initialScale = 1;
        let currentScale = 1;
        let initialAngle = 0;
        let currentAngle = 0;
        let currentX = 0;
        let currentY = 0;
        // const cardInfoId = overlayImage.getAttribute('data-card-info-id'); // 追加

        // DjangoのCSRFトークンを取得する関数
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    // Does this cookie string begin with the name we want?
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }
        const csrftoken = getCookie('csrftoken');

        // タッチイベント処理
        function handleTouchStart(event, image) {
            if (event.touches.length === 2 && image === baseImage) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                initialDistance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                initialScale = currentScale;

                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                const dx = touch1.clientX - centerX;
                const dy = touch1.clientY - centerY;
                initialAngle = Math.atan2(dy, dx);
            } else if (event.touches.length === 1) {
                const touch = event.touches[0];
                const rect = baseImage.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const x = touch.clientX - centerX;
                const y = touch.clientY - centerY;

                overlayImage.style.transform = `translate(${x}px, ${y}px)`;
                currentX = x;
                currentY = y;
            }
        }

        function handleTouchMove(event, image) {
            event.preventDefault();
            if (event.touches.length === 2 && image === baseImage) {
                const touch1 = event.touches[0];
                const touch2 = event.touches[1];
                const distance = Math.hypot(touch2.clientX - touch1.clientX, touch2.clientY - touch1.clientY);
                const scale = distance / initialDistance;
                currentScale = initialScale * scale;

                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                const dx = touch1.clientX - centerX;
                const dy = touch1.clientY - centerY;
                const angle = Math.atan2(dy, dx);
                currentAngle = angle - initialAngle;

                image.style.transform = `scale(${currentScale}) rotate(${currentAngle}rad)`;
            }
        }

        function handleTouchEnd(event, image) {
            if (event.touches.length < 2) {
                initialDistance = null;
            }
        }

        function handleTouchPosition(event, image) {
            const touch = event.touches[0];
            const rect = image.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const x = (touch.clientX - centerX) / currentScale;
            const y = (touch.clientY - centerY) / currentScale;
            const rotatedX = x * Math.cos(-currentAngle) - y * Math.sin(-currentAngle);
            const rotatedY = x * Math.sin(-currentAngle) + y * Math.cos(-currentAngle);

            console.log(`Touched at (x: ${rotatedX.toFixed(2)}, y: ${rotatedY.toFixed(2)})`);

            const coordinatesDisplay = document.createElement('div');
            coordinatesDisplay.style.position = 'absolute';
            coordinatesDisplay.style.top = `${touch.clientY}px`;
            coordinatesDisplay.style.left = `${touch.clientX}px`;
            coordinatesDisplay.textContent = `(x: ${rotatedX.toFixed(2)}, y: ${rotatedY.toFixed(2)})`;
            document.body.appendChild(coordinatesDisplay);

            setTimeout(() => {
                coordinatesDisplay.remove();
            }, 2000);
        }

        // マウスイベント処理
        let isDragging = false;

        function handleMouseDown(event) {
            isDragging = true;
        }

        function handleMouseMove(event) {
            if (isDragging) {
                const rect = baseImage.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const x = event.clientX - centerX;
                const y = event.clientY - centerY;

                overlayImage.style.transform = `translate(${x}px, ${y}px)`;
                currentX = x;
                currentY = y;
            }
        }

        function handleMouseUp(event) {
            isDragging = false;
        }

        baseImage.addEventListener('touchstart', (event) => handleTouchStart(event, baseImage));
        baseImage.addEventListener('touchmove', (event) => handleTouchMove(event, baseImage));
        baseImage.addEventListener('touchend', (event) => handleTouchEnd(event, baseImage));
        baseImage.addEventListener('touchcancel', (event) => handleTouchEnd(event, baseImage));
        baseImage.addEventListener('touchstart', (event) => handleTouchPosition(event, baseImage));

        overlayImage.addEventListener('touchstart', (event) => handleTouchStart(event, overlayImage));
        overlayImage.addEventListener('touchstart', (event) => handleTouchPosition(event, overlayImage));

        overlayImage.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mouseup', handleMouseUp);

        // 位置決定ボタンがクリックされたときの処理
        saveButton.addEventListener('click', function() {
            const postData = {
                x: currentX,
                y: currentY,
            };

            fetch('/save_position/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify(postData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'failure') {
                    console.error('Position save failed:', data.error);
                } else {
                    window.location.href = '/display_position/'
                    console.log('Position saved successfully');
                }
            })
            .catch(error => console.error('Error saving position:', error));
        });
    </script>
</body>
</html>


